// -*- mode: c++; -*-

#ifndef JETEVENT_EVENT_H_
#define JETEVENT_EVENT_H_

// LinkDef files generated by rootcint do not include config.h
#if defined(__CINT__) || defined(G__DICTIONARY)
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H
#endif // defined(__CINT__) || defined(G__DICTIONARY)

#include <cmath>
#include <vector>
#include <jetbase/num.h>
#include <jetevent/particle.h>

namespace jet {

	class reaction_plane_t {
	private:
		float _angle;
		cartesian_point_t _flow_q;
		float _flow_q_weight;
	public:
		inline reaction_plane_t(void)
			: _angle(NAN), _flow_q(NAN, NAN), _flow_q_weight(NAN)
		{
		}
		inline reaction_plane_t(const float angle,
								const cartesian_point_t flow_q,
								const float flow_q_weight)
			: _angle(angle), _flow_q(flow_q),
			  _flow_q_weight(flow_q_weight)
		{
		}
		inline operator float(void) const
		{
			return angle();
		}
		inline float &angle(void)
		{
			return _angle;
		}
		inline float angle(void) const
		{
			return _angle;
		}
		inline cartesian_point_t &flow_q(void)
		{
			return _flow_q;
		}
		inline cartesian_point_t flow_q(void) const
		{
			return _flow_q;
		}
		inline float &flow_q_weight(void)
		{
			return _flow_q_weight;
		}
		inline float flow_q_weight(void) const
		{
			return _flow_q_weight;
		}
	};

	class north_south_reaction_plane_t {
	private:
		reaction_plane_t _combined;
		reaction_plane_t _north;
		reaction_plane_t _south;
	public:
		inline north_south_reaction_plane_t(void)
		{
		}
		north_south_reaction_plane_t(const reaction_plane_t combined,
									 const reaction_plane_t north,
									 const reaction_plane_t south)
			: _combined(combined), _north(north), _south(south)
		{
		}
		inline operator float(void) const
		{
			return combined();
		}
		inline reaction_plane_t &combined(void)
		{
			return _combined;
		}
		inline reaction_plane_t combined(void) const
		{
			return _combined;
		}
		inline reaction_plane_t &north(void)
		{
			return _north;
		}
		inline reaction_plane_t north(void) const
		{
			return _north;
		}
		inline reaction_plane_t &south(void)
		{
			return _south;
		}
		inline reaction_plane_t south(void) const
		{
			return _south;
		}
	};

	class phenix_reaction_plane_t {
	private:
		north_south_reaction_plane_t _beam_beam_counter;
		north_south_reaction_plane_t _reaction_plane_combined;
		north_south_reaction_plane_t _reaction_plane_inner;
		north_south_reaction_plane_t _reaction_plane_outer;
		north_south_reaction_plane_t _muon_piston_calorimeter;
	public:
		inline phenix_reaction_plane_t(void)
		{
		}
		inline phenix_reaction_plane_t(
			const north_south_reaction_plane_t beam_beam_counter,
			const north_south_reaction_plane_t reaction_plane_combined,
			const north_south_reaction_plane_t reaction_plane_inner,
			const north_south_reaction_plane_t reaction_plane_outer,
			const north_south_reaction_plane_t muon_piston_calorimeter)
			: _beam_beam_counter(beam_beam_counter),
			  _reaction_plane_combined(reaction_plane_combined),
			  _reaction_plane_inner(reaction_plane_inner),
			  _reaction_plane_outer(reaction_plane_outer),
			  _muon_piston_calorimeter(muon_piston_calorimeter)
		{
		}
		inline operator float(void) const
		{
			if(std::isfinite(static_cast<float>(
					reaction_plane_combined())) &&
					reaction_plane_combined() > -9999.0F) {
				return reaction_plane_combined();
			}
			else if(std::isfinite(static_cast<float>(
					muon_piston_calorimeter())) &&
					muon_piston_calorimeter() > -9999.0F) {
				return muon_piston_calorimeter();
			}
			else {
				return beam_beam_counter();
			}
		}
		inline north_south_reaction_plane_t &beam_beam_counter(void)
		{
			return _beam_beam_counter;
		}
		inline north_south_reaction_plane_t beam_beam_counter(void) const
		{
			return _beam_beam_counter;
		}
		inline north_south_reaction_plane_t &reaction_plane_combined(void)
		{
			return _reaction_plane_combined;
		}
		inline north_south_reaction_plane_t reaction_plane_combined(void) const
		{
			return _reaction_plane_combined;
		}
		inline north_south_reaction_plane_t &reaction_plane_inner(void)
		{
			return _reaction_plane_inner;
		}
		inline north_south_reaction_plane_t reaction_plane_inner(void) const
		{
			return _reaction_plane_inner;
		}
		inline north_south_reaction_plane_t &reaction_plane_outer(void)
		{
			return _reaction_plane_outer;
		}
		inline north_south_reaction_plane_t reaction_plane_outer(void) const
		{
			return _reaction_plane_outer;
		}
		inline north_south_reaction_plane_t &muon_piston_calorimeter(void)
		{
			return _muon_piston_calorimeter;
		}
		inline north_south_reaction_plane_t muon_piston_calorimeter(void) const
		{
			return _muon_piston_calorimeter;
		}
	};

	class vertex_height_t {
	private:
		float _beam_beam_counter_mean;
		float _beam_beam_counter_error;
		float _zero_degree_calorimeter_mean;
		float _zero_degree_calorimeter_error;
	public:
		inline vertex_height_t(const float mean)
			: _beam_beam_counter_mean(mean),
			  _beam_beam_counter_error(0.0F),
			  _zero_degree_calorimeter_mean(mean),
			  _zero_degree_calorimeter_error(0.0F)
		{
		}
		inline
		vertex_height_t(const float beam_beam_counter_mean,
						const float beam_beam_counter_error,
						const float zero_degree_calorimeter_mean,
						const float zero_degree_calorimeter_error)
			: _beam_beam_counter_mean(beam_beam_counter_mean),
			  _beam_beam_counter_error(beam_beam_counter_error),
			  _zero_degree_calorimeter_mean(zero_degree_calorimeter_mean),
			  _zero_degree_calorimeter_error(zero_degree_calorimeter_error)
		{
		}
		inline float &beam_beam_counter_mean(void)
		{
			return _beam_beam_counter_mean;
		}
		inline float beam_beam_counter_mean(void) const
		{
			return _beam_beam_counter_mean;
		}
		inline float &beam_beam_counter_error(void)
		{
			return _beam_beam_counter_error;
		}
		inline float beam_beam_counter_error(void) const
		{
			return _beam_beam_counter_error;
		}
		inline float &zero_degree_calorimeter_mean(void)
		{
			return _zero_degree_calorimeter_mean;
		}
		inline float zero_degree_calorimeter_mean(void) const
		{
			return _zero_degree_calorimeter_mean;
		}
		inline float &zero_degree_calorimeter_error(void)
		{
			return _zero_degree_calorimeter_error;
		}
		inline float zero_degree_calorimeter_error(void) const
		{
			return _zero_degree_calorimeter_error;
		}
		inline operator float(void) const
		{
			return (!std::isfinite(_beam_beam_counter_mean) ||
					_beam_beam_counter_mean <= -9999.0) ?
				_zero_degree_calorimeter_mean :
				_beam_beam_counter_mean;
		}
		inline vertex_height_t &operator+=(const float shift)
		{
			_beam_beam_counter_mean += shift;
			_zero_degree_calorimeter_mean += shift;

			return *this;
		}
	};

	class supermodule_id_t : public phenix_calorimetry_t {
	private:
		static const unsigned int _lead_scintillator_sector_stride;
		static const unsigned int _lead_glass_sector_stride;
		static const unsigned int _lead_scintillator_z_stride;
		static const unsigned int _lead_glass_z_stride;
		static const unsigned int _rich_sector_stride = 4 * 8;
		static const unsigned int _rich_z_stride = 8;
		static const unsigned int _nsector_rich = 8;
		int _id;
		void set_supermodule_id(
			const int arm, const int sector,
			const int reduced_id, const bool rich);
	public:
		static const unsigned int lead_scintillator_offset;
		static const unsigned int lead_glass_offset;
		static const unsigned int rich_offset;
		static const unsigned int nsupermodule;
		inline supermodule_id_t(const int id = -1)
			: _id(id)
		{
		}
		supermodule_id_t(const int arm, const int sector,
						 const int reduced_id, const bool rich);
		supermodule_id_t(const int continuous_sector,
						 const int reduced_id, const bool rich);
		inline operator int(void) const
		{
			return _id;
		}
		inline bool lead_scintillator(void) const
		{
			return (_id >= 0 &&
					_id < static_cast<int>(lead_glass_offset));
		}
		inline bool lead_glass(void) const
		{
			return (_id >= static_cast<int>(lead_glass_offset) &&
					_id < static_cast<int>(rich_offset));
		}
		inline bool rich(void) const
		{
			return (_id >= static_cast<int>(rich_offset) &&
					_id < static_cast<int>(nsupermodule));
		}
		int sector(void) const;
		int reduced_id(void) const;
		int y(void) const;
		int z(void) const;
		float approximate_pseudorapidity(void) const;
		float approximate_azimuth(void) const;
	};

	inline bool tower_id_t::in(const supermodule_id_t &id) const
	{
		return supermodule() == id;
	}

	class ert_hit_t {
	public:
		enum {
			TRIGGER_MODE_4X4A = 0,
			TRIGGER_MODE_4X4B,
			TRIGGER_MODE_4X4C,
			TRIGGER_MODE_2X2,
			TRIGGER_MODE_RICH,
			NTRIGGER_MODE
		};
	private:
		unsigned int _trigger_mode;
		supermodule_id_t _supermodule;
		snowmass_vector_t _photon_momentum;
	public:
		ert_hit_t(void)
			: _trigger_mode(UINT_MAX), _supermodule(-1)
		{
		}
		ert_hit_t(const unsigned int trigger_mode,
				  const supermodule_id_t supermodule)
			: _trigger_mode(trigger_mode), _supermodule(supermodule)
		{
		}
		inline unsigned int &trigger_mode(void)
		{
			return _trigger_mode;
		}
		inline unsigned int trigger_mode(void) const
		{
			return _trigger_mode;
		}
		std::string trigger_mode_str(void) const;
		inline supermodule_id_t &supermodule(void)
		{
			return _supermodule;
		}
		inline supermodule_id_t supermodule(void) const
		{
			return _supermodule;
		}
		inline snowmass_vector_t photon_momentum(void) const
		{
			return _photon_momentum;
		}
		inline snowmass_vector_t &photon_momentum(void)
		{
			return _photon_momentum;
		}
	};

	class gl1_state_t {
	protected:
		uint32_t _raw;
		uint32_t _live;
		uint32_t _scaled;
	private:
		std::string binary_str(const uint32_t n) const;
	public:
		gl1_state_t(const uint32_t raw = 0U,
					const uint32_t live = 0U,
					const uint32_t scaled = 0U)
			: _raw(raw), _live(live), _scaled(scaled)
		{
		}
		inline uint32_t raw(void) const
		{
			return _raw;
		}
		inline uint32_t &raw(void)
		{
			return _raw;
		}
		inline std::string raw_binary_str(void) const
		{
			return binary_str(_raw);
		}
		inline uint32_t live(void) const
		{
			return _live;
		}
		inline uint32_t &live(void)
		{
			return _live;
		}
		inline std::string live_binary_str(void) const
		{
			return binary_str(_live);
		}
		inline uint32_t scaled(void) const
		{
			return _scaled;
		}
		inline uint32_t &scaled(void)
		{
			return _scaled;
		}
		inline std::string scaled_binary_str(void) const
		{
			return binary_str(_scaled);
		}
	};

	class event_t {
	protected:
		uint64_t _event_number;
		uint64_t _raw_time;
		float _scale_down;
		std::vector<jet::ert_hit_t> _ert_hit;
		gl1_state_t _gl1_state;
		vertex_height_t _vertex_height;
		float _bbc_t0;
		float _centrality;
		phenix_reaction_plane_t _reaction_plane;
		// Incomplete C++ namespace support in rootcint requires
		// fully qualified names in the templates below:
		std::vector<jet::track_t> _track;
		std::vector<jet::cluster_t> _cluster;
		std::vector<jet::cluster_t> _cluster_raw;
		std::vector<jet::particle_t> _parton;
	public:
		event_t(const uint64_t event_number = 0U,
				const uint64_t raw_time = 0U,
				const float scale_down = 1.0F,
				const std::vector<ert_hit_t> ert_hit =
				std::vector<ert_hit_t>(),
				const gl1_state_t gl1_state =
				gl1_state_t(0U, 0U, 0U),
				const vertex_height_t vertex_height =
				vertex_height_t(NAN, NAN, NAN, NAN),
				const float bbc_t0 = NAN,
				const float centrality = NAN,
				const phenix_reaction_plane_t reaction_plane =
				phenix_reaction_plane_t())
			: _event_number(event_number), _raw_time(raw_time),
			  _scale_down(scale_down), _ert_hit(ert_hit),
			  _gl1_state(gl1_state), _vertex_height(vertex_height),
			  _bbc_t0(bbc_t0), _centrality(centrality),
			  _reaction_plane(reaction_plane)
		{
		}
		event_t(const uint64_t event_number,
				const uint64_t raw_time,
				const float scale_down,
				const std::vector<track_t> track,
				const std::vector<cluster_t> cluster,
				const std::vector<cluster_t> cluster_raw =
				std::vector<cluster_t>(),
				const std::vector<particle_t> parton =
				std::vector<particle_t>(),
				const std::vector<ert_hit_t> ert_hit =
				std::vector<ert_hit_t>(),
				const gl1_state_t gl1_state =
				gl1_state_t(0U, 0U, 0U),
				const vertex_height_t vertex_height =
				vertex_height_t(NAN, NAN, NAN, NAN),
				const float bbc_t0 = NAN,
				const float centrality = NAN,
				const phenix_reaction_plane_t reaction_plane =
				phenix_reaction_plane_t())
			: _event_number(event_number), _raw_time(raw_time),
			  _scale_down(scale_down), _ert_hit(ert_hit),
			  _gl1_state(gl1_state), _vertex_height(vertex_height),
			  _bbc_t0(bbc_t0), _centrality(centrality),
			  _reaction_plane(reaction_plane), _track(track),
			  _cluster(cluster), _cluster_raw(cluster_raw), _parton(parton)
		{
		}
		inline uint64_t &event_number(void)
		{
			return _event_number;
		}
		inline uint64_t event_number(void) const
		{
			return _event_number;
		}
		inline uint64_t &raw_time(void)
		{
			return _raw_time;
		}
		inline uint64_t raw_time(void) const
		{
			return _raw_time;
		}
		inline float scale_down(void) const
		{
			return _scale_down;
		}
		inline float &scale_down(void)
		{
			return _scale_down;
		}
		inline float weight(void) const
		{
			return scale_down();
		}
		inline std::vector<ert_hit_t> ert_hit(void) const
		{
			return _ert_hit;
		}
		inline std::vector<ert_hit_t> &ert_hit(void)
		{
			return _ert_hit;
		}
		inline const gl1_state_t gl1_state(void) const
		{
			return _gl1_state;
		}
		inline const gl1_state_t &gl1_state(void)
		{
			return _gl1_state;
		}
		inline vertex_height_t &vertex_height(void)
		{
			return _vertex_height;
		}
		inline vertex_height_t vertex_height(void) const
		{
			return _vertex_height;
		}
		inline float bbc_t0(void) const
		{
			return _bbc_t0;
		}
		inline float &bbc_t0(void)
		{
			return _bbc_t0;
		}
		inline float centrality(void) const
		{
			return _centrality;
		}
		inline float &centrality(void)
		{
			return _centrality;
		}
		inline phenix_reaction_plane_t reaction_plane(void) const
		{
			return _reaction_plane;
		}
		inline phenix_reaction_plane_t &reaction_plane(void)
		{
			return _reaction_plane;
		}
		inline std::vector<track_t> track(void) const
		{
			return _track;
		}
		inline std::vector<track_t> &track(void)
		{
			return _track;
		}
		inline std::vector<cluster_t> cluster(void) const
		{
			return _cluster;
		}
		inline std::vector<cluster_t> &cluster(void)
		{
			return _cluster;
		}
		inline std::vector<cluster_t> cluster_raw(void) const
		{
			return _cluster_raw;
		}
		inline std::vector<cluster_t> &cluster_raw(void)
		{
			return _cluster_raw;
		}
		inline std::vector<particle_t> parton(void) const
		{
			return _parton;
		}
		inline std::vector<particle_t> &parton(void)
		{
			return _parton;
		}
		inline unsigned long size(void) const
		{
			return _track.size() + _cluster.size();
		}
		void print(void) const;
		event_t filter(bool (*track_filter)(const track_t),
					   bool (*cluster_filter)(const cluster_t))
			const;
		event_t final_state_filter(void) const;
		event_t rectangular_filter(
			const std::pair<float, float> pseudorapidity_range,
			const std::pair<float, float> azimuth_range) const;
		event_t tower_scale(const float cluster_tower_scale[]) const;
		event_t tower_map_filter(const bool tower_map[]) const;
#if 1
		void tower_diagnostics(
			const std::pair<float, float> pseudorapidity_range,
			const std::pair<float, float> azimuth_range,
			const float threshold = 0.5F) const;
#endif
		inline int multiplicity(void) const
		{
			return _track.size() + _cluster.size();
		}
		float total_perp(void) const;
		event_t operator+(const event_t &e) const;
		event_t operator+=(const event_t &e);
		event_t rotate(const float azimuth) const;
		void apply_phenix_tracking_cut(
			bool &bad_event, const bool high_quality,
			const bool x1_x2_large_perp);
		event_t vertex_align(const event_t &e) const;
		std::vector<cluster_t> cluster_reconstruct(
			const bool tower_map[],
			const float cluster_tower_scale[]) const;
		std::vector<cluster_t> cluster_reconstruct_no_recal(void) const;
		event_t phenix_reconstruct(
			bool &bad_event, const bool tower_map[],
			const float cluster_tower_scale[],
			const float run_timing_mean[],
			const float tower_timing_mean[],
			const float tower_timing_standard_deviation[],
			const bool high_quality,
			const bool x1_x2_large_perp,
			const bool apply_timing_cut,
			const bool reconstruct_neutral_pion) const;
		friend class event_file_t;
	};

	class event_input_t {
	public:
		inline virtual event_input_t &
		operator>>(event_t &event) = 0;
		inline virtual bool eof(void) const = 0;
	};

	class event_output_t {
	public:
		inline virtual event_input_t &
		operator<<(const event_t &event) = 0;
	};

	void reset_cut_statistics(void);
	const uint64_t *cut_statistics(void);
	const size_t cut_statistics_size(void);
}

#endif // JETEVENT_EVENT_H_
