// -*- mode: c++; -*-

/////////////////////////////////////////////////////////////////////

#ifndef JETEVENT_SNOWMASS_H_
#define JETEVENT_SNOWMASS_H_

// LinkDef files generated by rootcint do not include config.h
#if defined(__CINT__) || defined(G__DICTIONARY)
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H
#endif // defined(__CINT__) || defined(G__DICTIONARY)

#if defined(HAVE_ROOT) && !defined(NVERIFY)
#include <TLorentzVector.h>
#endif // defined(HAVE_ROOT) && !defined(NVERIFY)

#include <iostream>
#include <jetbase/dbc.h>
#include <jetbase/num.h>
#include <jetbase/specfunc.h>
#include <jetevent/lorentz.h>

// JET RECONSTRUCTION NUMERICS - SNOWMASS KINEMATICS

namespace jet {

	class event_file_t;
	class reconstruction_filtering_t;

#ifdef __INTEL_COMPILER
#pragma warning(push)
#pragma warning(disable: 1125)
#endif // __INTEL_COMPILER
#ifdef HAVE_ROOT
	// Sadly, CINT does not support any in-language alignment
	// specification, i.e. neither the GNU style __attribute__, nor
	// the Microsoft/Intel __declspec.
#ifdef __INTEL_COMPILER
#pragma pack(push)
#endif // __INTEL_COMPILER
#pragma pack(16)
#endif // HAVE_ROOT

	class snowmass_vector_t : public abstract_lorentz_vector_t {
	protected:
		float _x[4];
	public:
		inline snowmass_vector_t(void)
		{
		}

		inline snowmass_vector_t(const float vector[4])
		{
			I(_x != NULL);

			_x[0] = vector[0];
			_x[1] = vector[1];
			_x[2] = vector[2];
			_x[3] = vector[3];
		}

		snowmass_vector_t(const float time, const float perp,
						  const float pseudorapidity,
						  const float azimuth);
		inline snowmass_vector_t(lorentz_vector_t v)
		{
			set_time(v[0]);
			set_x_y_z(v[1], v[2], v[3]);

			I(FEQ(time(), v[0]));
			I(FEQ(x(), v[1]));
			I(FEQ(y(), v[2]));
			IG(FEQ(z(), v[3]), v[3] >= 8 && v[3] <= 8);
		}

#ifndef __CINT__
		operator lorentz_vector_t(void) const;
#endif // __CINT__

		/**
		 * Set the time component (usually the energy)
		 *
		 * @param[in]	time	time component (usually the energy)
		 */
		void set_time(const float time);

		/**
		 * Construct the Cartesian components for a given transverse
		 * magnitude perp, pseudorapidity, and azimuth angle
		 *
		 * @param[in]	perp	transverse momentum
		 * @param[in]	pseudorapidity	pseudorapidity
		 * @param[in]	azimuth	azimuth
		 */
		void set_perp_pseudorapidity_azimuth(
			const float perp, const float pseudorapidity,
			const float azimuth);
		/**
		 * Construct the Cartesian components for given Cartesian x,
		 * y, z components
		 *
		 * @param[in]	x	component along the x axis
		 * @param[in]	y	component along the y axis
		 * @param[in]	z	component along the z axis
		 */
		void set_x_y_z(const float x, const float y,
					   const float z);

		inline float *data(void)
		{
			I(_x != NULL);

			return _x;
		}

		inline const float *data(void) const
		{
			I(_x != NULL);

			return _x;
		}

		inline float &operator[](const int idx)
		{
			I(_x != NULL);

			return _x[idx];
		}

		/**
		 * Returns the time component (usually the energy)
		 *
		 * @returns time component (usually the energy)
		 */
		inline float &time(void)
		{
			I(_x != NULL);

			return _x[0];
		}

		/**
		 * Returns the time component (usually the energy)
		 *
		 * @returns time component (usually the energy)
		 */
		inline float time(void) const
		{
			I(_x != NULL);

			return _x[0];
		}

		inline float &perp(void)
		{
			I(_x != NULL);

			return _x[1];
		}

		inline float perp(void) const
		{
			I(_x != NULL);
			//I(F(_x[1]));
			//I(_x[1] >= 0);

			return _x[1];
		}

		inline float perp_square(void) const
		{
			I(_x != NULL);
			I(F(_x[1]));
			//I(_x[1] >= 0);

			return _x[1] * _x[1];
		}

		inline float &pseudorapidity(void)
		{
			I(_x != NULL);

			return _x[2];
		}

		inline float pseudorapidity(void) const
		{
			I(_x != NULL);
			I(F(_x[2]));

			return _x[2];
		}

		inline float &azimuth(void)
		{
			I(_x != NULL);

			return _x[3];
		}

		inline float azimuth(void) const
		{
			I(_x != NULL);
			I(F(_x[3]));
			I(FRANGE(_x[3], -M_PI, M_PI));

			return _x[3];
		}

		float x(void) const;
		float y(void) const;
		float z(void) const;
		// Calculate the Cartesian norm (|p|)
		float cartesian_magnitude(void) const;
		// Calculate the Cartesian norm squared (|p|^2)
		float cartesian_magnitude_square(void) const;
		snowmass_vector_t recombine(const snowmass_vector_t &v)
			const;
		float cos_polar_angle(void) const;
		float sin_polar_angle(void) const;
		float cartesian_dot(const snowmass_vector_t &v) const;

		inline snowmass_vector_t operator*(const float &s) const
		{
			return snowmass_vector_t(_x[0] * s, _x[1] * s,
									 _x[2], _x[3]);
		}

		float radial_distance_square(const snowmass_vector_t &v)
			const;
		float radial_distance(const snowmass_vector_t &v) const;
		float radial_origin_distance(void) const;

		inline float longitudinal_fraction(const snowmass_vector_t &v)
			const
		{
			return cartesian_dot(v) / v.cartesian_magnitude_square();
		}

		inline float transverse_magnitude(const snowmass_vector_t &v)
			const
		{
			lorentz_vector_t l = *this;
			lorentz_vector_t vl = v;

			return l.transverse_magnitude(vl);
		}

		// Specialized routines

		void set_lightlike_perp(void);
		void set_lightlike_time(void);

		friend class event_file_t;
		friend class reconstruction_filtering_t;
#ifdef __CINT__
	};
#else // __CINT__
	}
#ifndef HAVE_ROOT
	__attribute__ ((aligned(16)))
#endif // HAVE_ROOT
	;
#endif // __CINT__

#ifdef HAVE_ROOT
#ifdef __INTEL_COMPILER
#pragma pack(pop)
#endif // __INTEL_COMPILER
#endif // HAVE_ROOT
#ifdef __INTEL_COMPILER
#pragma warning(pop)
#endif // __INTEL_COMPILER

	inline bool descending_perp(
		const snowmass_vector_t u, const snowmass_vector_t v)
	{
		return u.perp() > v.perp();
	}

	inline bool ascending_perp(
		const snowmass_vector_t u, const snowmass_vector_t v)
	{
		return u.perp() < v.perp();
	}

	inline bool descending_mass_perp(
		const snowmass_vector_t u, const snowmass_vector_t v)
	{
		return u.mass_perp() > v.mass_perp();
	}

	inline bool ascending_mass_perp(
		const snowmass_vector_t u, const snowmass_vector_t v)
	{
		return u.mass_perp() < v.mass_perp();
	}

	inline bool operator<(
		const snowmass_vector_t u, const snowmass_vector_t v)
	{
		return descending_perp(u, v);
	}

}

#endif // JETEVENT_SNOWMASS_H_
