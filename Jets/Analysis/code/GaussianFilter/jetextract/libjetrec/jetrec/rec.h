// -*- mode: c++; -*-

#ifndef XJETREC_REC_H_
#define XJETREC_REC_H_

// LinkDef files generated by rootcint do not include config.h
#if defined(__CINT__) || defined(G__DICTIONARY)
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H
#endif // defined(__CINT__) || defined(G__DICTIONARY)

#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <functional>

#ifdef HAVE_MKL
#include <mkl_dfti.h>
#endif // HAVE_MKL
#ifdef HAVE_KTJET
#include <KtJet/KtEvent.h>
#include <KtJet/KtLorentzVector.h>
#endif // HAVE_KTJET
#ifdef HAVE_FASTJET
#include <fastjet/PseudoJet.hh>
#include <fastjet/ClusterSequence.hh>
#include <fastjet/ClusterSequenceArea.hh>
#include <fastjet/SISConePlugin.hh>
#ifdef HAVE_FASTJET_PXCONE
#include <fastjet/PxConePlugin.hh>
#endif // HAVE_FASTJET_PXCONE
#ifdef HAVE_FASTJET_CDF_MID_POINT
#include <fastjet/CDFMidPointPlugin.hh>
#endif // HAVE_FASTJET_CDF_MID_POINT
#endif // HAVE_FASTJET

#include <jetbase/dbc.h>
#include <jetbase/num.h>
#include <jetevent/snowmass.h>
#include <jetevent/particle.h>
#include <jetrec/jet.h>
#include <jetrec/background.h>
#include <jetrec/solve.h>
#ifdef HAVE_CUDA
#include <jetrec/cuda.h>
#endif // HAVE_CUDA

/////////////////////////////////////////////////////////////////////

// Classical and Filtering-Based Jet Reconstruction

// External filtering drivers:
// - Intel Math Kernel Library (CPU-based for IA-32/AMD64/Intel 64)
// - NVIDIA CUDA (GPU-based for GeForce 8 and later)

namespace {
	// Default parameters

	// OUTDATED: The default longitudinal momentum fraction (z) limit,
	// suitable for PHENIX and jets with p_T < 12 GeV/c (higher p_T
	// require explicit handling of conversion tracks)
	const float default_longitudinal_momentum_fraction_limit = 0.95F;
	// The default kT distance scale (ATLAS and CMS use 0.4 or 0.6)
	const double default_kt_distance = 1.0;
	// The default cone radius (ATLAS uses 0.4 or 0.7, CMS uses 0.5 or
	// 0.7)
	const double default_cone_radius = 0.7;
	// The default SISCone overlap threshold, chosen by LHC ATLAS
	// experiment (CMS uses 0.75)
	const double default_siscone_overlap_threshold = 0.5;

	// This is the level at which the fake jet passing pT/area
	// rejection is at the Ncoll scaled p + p cross section
	const double default_sigma_perp_over_area_background_threshold =
		3.0;

#ifdef HAVE_FASTJET_PXCONE
	// Definitions for cone variants used for comparison only
	// PXCONE
	const double default_min_jet_energy = 5.0;
#endif // HAVE_FASTJET_PXCONE
#ifdef HAVE_FASTJET_CDF_MID_POINT
	// CDF midpoint
	const double default_seed_threshold = 1.0;
#endif // HAVE_FASTJET_CDF_MID_POINT

	// STAR's "leading order" high seeded cone
	const double default_lohsc_seed_perp = 4.6;
	const double default_lohsc_fragment_cut_perp = 2.0;
	const double default_lohsc_inner_cone_radius = 0.4;
	const double default_lohsc_outer_cone_radius = 0.7;
}

namespace jet {

#ifdef __INTEL_COMPILER
#pragma warning(push)
#pragma warning(disable: 869)
#endif // __INTEL_COMPILER

	/**
	 * Abstract jet reconstruction model
	 */
	class reconstruction_t {
	private:
		/**
		 * Print a verbose feedback if either design-by-contract or
		 * more expensive verifications are active.
		 */
		inline void warn_dbc(void) const
		{
#if defined(HAVE_NANA) && !defined(NDEBUG)
			std::cerr << __FILE__ << ':' << __LINE__ << ": information: "
				"design-by-contract assertions are active, "
				"performance is likely degraded" << std::endl;
#endif // defined(HAVE_NANA) && !defined(NDEBUG)
#ifndef NVERIFY
			std::cerr << __FILE__ << ':' << __LINE__ << ": information: "
				"additional verification are active, performance "
				"is likely degraded" << std::endl;
#endif // NVERIFY
		}
	protected:
		inline reconstruction_t(void)
		{
			warn_dbc();
		}
	public:
		virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true) = 0;
		virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true) = 0;
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const = 0;
		inline virtual ~reconstruction_t(void)
		{
		}
	};

#ifdef __INTEL_COMPILER
#pragma warning(pop)
#endif // __INTEL_COMPILER

#ifdef __INTEL_COMPILER
#pragma warning(push)
#pragma warning(disable: 869)
#pragma warning(disable: 1125)
#endif // __INTEL_COMPILER

	/**
	 * Abstract filtering based reconstruction (i.e., without
	 * specifying the filtering algorithm detail)
	 */
	class reconstruction_filtering_t : public reconstruction_t {
	public:
		enum {
			FILTER_TYPE_GAUSSIAN = 0,
			FILTER_TYPE_EPANECHNIKOV,
			FILTER_TYPE_DELTA
		};
	protected:
		enum {
			STATUS_CONTINUE = 0,
			STATUS_CONVERGENCE,
			STATUS_HESSIAN_INDEFINITE,
			STATUS_HESSIAN_SINGULAR,
			STATUS_SADDLE_POINT,
			STATUS_NOT_NUMERICAL,
			STATUS_LINE_SEARCH_CONTINUE,
			STATUS_LINE_SEARCH_CONVERGENCE,
			STATUS_LINE_SEARCH_STEP_LIMIT,
			STATUS_LINE_SEARCH_INVALID_BRACKET,
			STATUS_LINE_SEARCH_NOT_DESCENDING,
			STATUS_LINE_SEARCH_INVALID_RANGE,
			STATUS_LINE_SEARCH_NOT_NUMERICAL
		};
	private:
		static const char *status_str(const unsigned int status);
		/**
		 * Modify an indefinite Hessian for quasi-Newton maximization
		 * by spectral decomposition
		 *
		 * @param[out]	modified_hessian	the modified Hessian
		 * @param[in]	hessian				the original Hessian
		 */
		void modify_hessian_spectral(
			float modified_hessian[], const float hessian[]) const;
		/**
		 * Modify an indefinite Hessian for quasi-Newton maximization
		 * by modified Cholesky factorization
		 *
		 * @param[out]	modified_hessian	the modified Hessian
		 * @param[in]	hessian				the original Hessian
		 */
		void modify_hessian_modified_cholesky(
			float modified_hessian[], const float hessian[]) const;
		/**
		 * Evaluate one iteration step for the continuous maximization
		 */
		void evaluate_step(
			float &perp, float gradient[], float hessian[],
			const jet_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
		/**
		 * Evaluate one iteration step for the continuous maximization
		 * and Gaussian filter kernel
		 */
		void evaluate_step_gaussian(
			float &perp, float gradient[], float hessian[],
			const jet_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
#ifdef HAVE_SSE
		/**
		 * Evaluate one iteration step for the continuous maximization
		 * and Gaussian filter kernel, SSE implementation
		 */
		void evaluate_step_gaussian_sse(
			float &perp, float gradient[], float hessian[],
			const jet_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
#endif // HAVE_SSE
		/**
		 * Evaluate one iteration step for the continuous maximization
		 * and Epanechnikov (parabolic) kernel
		 */
		void evaluate_step_epanechnikov(
			float &perp, float gradient[], float hessian[],
			const jet_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
		/**
		 * Constrain the iterated direction within the pseudorapidity
		 * range
		 */
		void constrain_newton_direction_pseudorapidity(
			float &newton_direction_pseudorapidity,
			float &newton_direction_azimuth,
			const float pseudorapidity) const;
		/**
		 * Evaluate a 2D quadratic local expansion
		 */
		float evaluate_quadratic(
			const float x0, const float x1,
			const float gradient[], const float hessian[]) const;
		/**
		 * Evaluate the determinant of a 2x2 matrix
		 */
		float determinant_2(const float a[]) const;
		/**
		 * Solve the unconstrained quadratic optimization problem
		 */
		void solve_quadratic_unconstrained_2(
			float &x0, float &x1,
			const float gradient[], const float hessian[],
			const float determinant) const;
		/**
		 * Solve the quadratic optimization problem with an axial
		 * constraint in the x0 direction
		 */
		bool solve_quadratic_constrained_2_0(
			float &x0, const float x1,
			const float x0_min, const float x0_max,
			const float gradient[], const float hessian[]) const;
		/**
		 * Solve the quadratic optimization problem with an axial
		 * constraint in the x1 direction
		 */
		bool solve_quadratic_constrained_2_1(
			const float x0, float &x1,
			const float x1_min, const float x1_max,
			const float gradient[], const float hessian[]) const;
		/**
		 * Solve the quadratic optimization problem with an axial box
		 * constraint in the x0, x1 directions
		 */
		void solve_quadratic_constrained_2(
			float &max_x0, float &max_x1,
			const float x0_min, const float x0_max,
			const float x1_min, const float x1_max,
			const float gradient[], const float hessian[]) const;
		int line_search_more_thuente_step(
			float &step_best, float &function_best,
			float &derivative_best,
			float &step_second, float &function_second,
			float &derivative_second,
			float &step_current, float &function_current,
			float &derivative_current, bool &bracketed,
			const float step_min, const float step_max) const;
		unsigned int solve_trust_region(
			float &newton_direction_pseudorapidity,
			float &newton_direction_azimuth,
			float &scaled_norm, bool &constrained,
			const float perp, const float gradient[],
			const float hessian[],
			const float determinant, const float gradient_norm,
			const float scaled_norm_limit, const bool constrain) const;
		unsigned int solve_line_search(
			float &step, const float newton_direction_pseudorapidity,
			const float newton_direction_azimuth,
			const jet_t &jet, const float perp, const float gradient[],
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
		unsigned int refine_jet_maximum_step(
			jet_t &jet, snowmass_vector_t &previous_momentum,
			float &previous_determinant, float &scaled_norm_limit,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const float perp, const float gradient[],
			const float hessian[], const int iteration,
			const float precision,
			const collision_geometry_t &geometry,
			const bool biased_wolfe = false)
			const;
	protected:
		unsigned int _filter_type;
		float _standard_deviation;
		std::pair<float, float> _pseudorapidity_range;
		std::pair<float, float> _azimuth_range;
		int _npixel_pseudorapidity;
		int _npixel_azimuth;
		int _npixel;
		const background_model_t *_background_perp;
		const background_model_t *_background_time;
		const background_model_t *_background_z;
		float *_distribution;
		float *_intermediate;
		float *_background_cache;
		float *_factorized_background_cache;
#ifdef HAVE_SSE
		// The nature of SSE base maximum finder requires the
		// allocation of two intermediate storage
		float *_maximum_2;
		float *_maximum_3;
#endif // HAVE_SSE
		bool *_maximum;
		float _continuum_normalization;
	public:
		snowmass_vector_t _test_jet;
		std::vector<track_t> _test_track;
	protected:
		void allocate_host(void);
		void free_host(void);
		void fill(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			bool column_occupancy[]) const;
		void fill(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			bool column_occupancy[],
			const snowmass_vector_t &perturbation) const;
		virtual void filter(const bool column_occupancy[]) = 0;
		void maximum_map(void) const;
		void stationary_map(void) const;
#ifdef HAVE_SSE
		void maximum_map_sse(void) const;
#endif // HAVE_SSE
#ifdef HAVE_SSE2
		void stationary_map_sse2(void) const;
#endif // HAVE_SSE
		std::vector<jet_t> find_jet_maximum(void);
		void background_initialize(void);
		void background_compensate(
			const collision_geometry_t &geometry);
		void
		refine_jet_maximum(
			jet_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry) const;
		void filter_spatial_domain(void);
		void gaussian_filter_spatial_domain(void);
		void epanechnikov_filter_spatial_domain(void);
		reconstruction_filtering_t(
			const float standard_deviation,
			const std::pair<float, float> pseudorapidity_range,
			const int npixel_pseudorapidity,
			const background_model_t &background_perp,
			const background_model_t &background_time,
			const background_model_t &background_z,
			const float *background_cache,
			const int npixel_azimuth,
			const std::pair<float, float> azimuth_range)
			: _standard_deviation(standard_deviation),
			  _pseudorapidity_range(pseudorapidity_range),
			  _azimuth_range(azimuth_range),
			  _npixel_pseudorapidity(npixel_pseudorapidity),
			  _npixel_azimuth(npixel_azimuth),
			  _npixel(npixel_pseudorapidity * npixel_azimuth),
			  _background_perp(&background_perp),
			  _background_time(&background_time),
			  _background_z(&background_z),
			  _distribution(NULL), _intermediate(NULL),
#ifdef HAVE_SSE
			  _maximum_2(NULL), _maximum_3(NULL),
#endif // HAVE_SSE
			  _maximum(NULL)
		{
			_continuum_normalization =
				((_pseudorapidity_range.second -
				  _pseudorapidity_range.first) *
				 (_azimuth_range.second - _azimuth_range.first)) /
				((float)_npixel_pseudorapidity *
				 (float)_npixel_azimuth);

			// FIXME: I need to deal with non-multiples-of-4 azimuthal
			// grid sizes later.
#ifdef HAVE_SSE
			I((_npixel_azimuth & 3) == 0);
#endif // HAVE_SSE
			allocate_host();
			if(background_cache != NULL) {
				memcpy(_background_cache, background_cache,
					   101 * 32 * _npixel * sizeof(float));
			}
			else {
				background_initialize();
			}
		}
		~reconstruction_filtering_t(void)
		{
			free_host();
		}
	public:
		/**
		 * Returns the XML attribute value for the dimensional
		 * ordering of the discrete filter density in the form of
		 * "minor:major"
		 *
		 * @return	XML ordering attribute
		 */
		inline std::string ordering_xml_attribute(void) const
		{
			return "azimuth:pseudorapidity";
		}
		/**
		 * Returns the number of discrete filter pixels
		 *
		 * @return	number of pixels
		 */
		inline int npixel(void) const
		{
			return _npixel;
		}
		inline int npixel_pseudorapidity(void) const
		{
			return _npixel_pseudorapidity;
		}
		inline int npixel_azimuth(void) const
		{
			return _npixel_azimuth;
		}
		inline std::pair<float, float> pseudorapidity_range(void)
			const
		{
			return _pseudorapidity_range;
		}
		inline float standard_deviation(void) const
		{
			return _standard_deviation;
		}
		inline float exponent_scale(void) const
		{
			return -0.5F /
				(_standard_deviation * _standard_deviation);
		}
		inline std::pair<float, float> azimuth_range(void) const
		{
			return _azimuth_range;
		}
		inline const float *distribution(void) const
		{
			return _distribution;
		}
		inline const bool *maximum(void) const
		{
			return _maximum;
		}
		std::vector<jet_t> raw_reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry);
		inline std::vector<jet_t> raw_reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry)
		{
			return raw_reconstruct(track.begin(), track.end(),
								   geometry);
		}
		std::vector<jet_t>
		ghost_cut(const std::vector<jet_t> &jet) const;
		/**
		 * Reconstruct a track based event
		 *
		 * @param[in] track_begin first event track iterator
		 * @param[in] track_end next to the last track iterator
		 * @param[in] centrality centrality in [0, 100] for heavy ion
		 * collisions, NAN otherwise
		 * @param[in] refine iteratively refine the discrete result to
		 * obtain continuous jet directions
		 * @return jets
		 */
		std::vector<jet_t> reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true);
		/**
		 * Reconstruct a track based event
		 *
		 * @param[in] track event tracks
		 * @param[in] centrality centrality in [0, 100] for heavy ion
		 * collisions, NAN otherwise
		 * @param[in] refine iteratively refine the discrete result to
		 * obtain continuous jet directions
		 * @return jets
		 */
		inline std::vector<jet_t> reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		/**
		 * Reconstruct a track based event for non-heavy ion collisions
		 *
		 * @param[in] track_begin first event track iterator
		 * @param[in] track_end next to the last track iterator
		 * @param[in] refine iteratively refine the discrete result to
		 * obtain continuous jet directions
		 * @return jets
		 */
		inline std::vector<jet_t> reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true)
		{
			return reconstruct(
				track_begin, track_end, collision_geometry_t(),
				refine);
		}
		/**
		 * Reconstruct a track based event for non-heavy ion collisions
		 *
		 * @param[in] track event tracks
		 * @param[in] refine iteratively refine the discrete result to
		 * obtain continuous jet directions
		 * @return jets
		 */
		inline std::vector<jet_t> reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(
				track.begin(), track.end(), collision_geometry_t(),
				refine);
		}
		/**
		 * Reconstruct track based heavy ion event generator string
		 * system
		 *
		 * @param[in] track_begin first event track iterator
		 * @param[in] track_end next to the last track iterator
		 * @param[in] refine_momentum_limit minimum transverse
		 * momentum for iterative refineed continuous jet directions
		 * @return string system partons
		 */
		std::vector<jet_t> embedded_reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const float refine_momentum_limit = 0.0F);
		void
		longitudinal_momentum_fraction_renormalize(
			float &longitudinal_momentum_fraction,
			const snowmass_vector_t &jet_momentum,
			const snowmass_vector_t &track_momentum) const;
		std::vector<jet_t>
		apply_longitudinal_momentum_fraction_limit(
			const std::vector<jet_t> raw_jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const float longitudinal_momentum_fraction_limit =
			default_longitudinal_momentum_fraction_limit)
			const;
		// Jet tagging related
		float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const;
		inline float
		filter_weight_eval_ext(const std::vector<float> x) const
		{
			return filter_weight(
				snowmass_vector_t(1, 1, x[0], x[1]), _test_jet);
		}
		float filter_density(
			const snowmass_vector_t &fragment,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end)
			const;
		inline float filter_density(
			const snowmass_vector_t &fragment,
			const std::vector<track_t> &track) const
		{
			return filter_density(
				fragment, track.begin(), track.end());
		}
		float bayesian_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const float radial_broadening = 0.0F) const;
		inline float bayesian_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const std::vector<track_t> &track,
			const float radial_broadening = 0.0F) const
		{
			return bayesian_weight(
				fragment, jet, track.begin(), track.end(),
				radial_broadening);
		}
		inline float
		bayesian_weight_eval_ext(const std::vector<float> x) const
		{
			return bayesian_weight(
				snowmass_vector_t(1, 1, x[0], x[1]),
				_test_jet, _test_track);
		}
		inline float weighted_longitudinal_fraction(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet) const
		{
			const float w = filter_weight(fragment, jet);
			const float z = fragment.longitudinal_fraction(jet);

			if(std::fpclassify(w) == FP_ZERO ||
			   std::fpclassify(z) == FP_ZERO)
				return 0;

			return w * z;
		}
		lorentz_vector_t background_lorentz_jet(
			const snowmass_vector_t &momentum,
			const collision_geometry_t &geometry) const;
		snowmass_vector_t bayesian_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const;
		inline snowmass_vector_t bayesian_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const
		{
			return bayesian_jet(
				jet, track.begin(), track.end(),
				geometry, transverse_momentum_broadening);
		}
		inline snowmass_vector_t pseudobayesian_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const
		{
			snowmass_vector_t ret =
				bayesian_jet(
					jet, track_begin, track_end,
					geometry, transverse_momentum_broadening);

			ret.pseudorapidity() = jet.pseudorapidity();
			ret.azimuth() = jet.azimuth();
			ret.set_lightlike_time();

			return ret;
		}
		inline snowmass_vector_t pseudobayesian_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const
		{
			return pseudobayesian_jet(
				jet, track.begin(), track.end(),
				geometry, transverse_momentum_broadening);
		}
		lorentz_vector_t lorentz_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const;
		inline lorentz_vector_t lorentz_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry =
			collision_geometry_t(),
			const float transverse_momentum_broadening = 0.0F) const
		{
			return lorentz_jet(
				jet, track.begin(), track.end(),
				geometry, transverse_momentum_broadening);
		}
		snowmass_vector_t first_order_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const float transverse_momentum_broadening = 0.0F)
			const;
		inline snowmass_vector_t first_order_jet(
			const snowmass_vector_t &jet,
			const std::vector<track_t> &track,
			const float transverse_momentum_broadening = 0.0F) const
		{
			return first_order_jet(
				jet, track.begin(), track.end(),
				transverse_momentum_broadening);
		}
		inline float content(
			const jet_t &jet,
			std::vector<track_t> track,
			std::const_mem_fun_ref_t<bool, particle_t>
			member_function) const
		{
			float sum_match = 0;
			float sum_total = 0;

			for(std::vector<track_t>::const_iterator iterator =
					track.begin();
				iterator != track.end(); iterator++)
				if(iterator->is_final_state()) {
					const float weight =
						weighted_longitudinal_fraction(
							iterator->momentum(), jet);

					if(member_function(*iterator))
						sum_match += weight;
					sum_total += weight;
				}

			return std::fpclassify(sum_total) != FP_ZERO ?
				sum_match / sum_total : 0.0F;
		}
		inline float content(
			const jet_t &jet,
			std::vector<track_t> track,
			std::const_mem_fun1_ref_t<bool, particle_t,
			std::vector<track_t> > member_function) const
		{
			float sum_match = 0;
			float sum_total = 0;

			for(std::vector<track_t>::const_iterator iterator =
					track.begin();
				iterator != track.end(); iterator++)
				if(iterator->is_final_state()) {
					const float weight =
						weighted_longitudinal_fraction(
							iterator->momentum(), jet);

					if(member_function(*iterator, track))
						sum_match += weight;
					sum_total += weight;
				}

			return std::fpclassify(sum_total) != FP_ZERO ?
				sum_match / sum_total : 0.0F;
		}
		template<typename property_t, typename comparison_t>
		inline float first_initial_state_content(
			const jet_t &jet,
			const std::vector<track_t> &track,
			std::binder2nd<comparison_t> comparison,
			std::const_mem_fun_ref_t<property_t, particle_t>
			member_function) const
		{
			float sum_match = 0;
			float sum_total = 0;

			for(std::vector<track_t>::const_iterator iterator =
					track.begin();
				iterator != track.end(); iterator++)
				if(iterator->is_final_state()) {
					std::vector<track_t>::const_iterator
						iterator_initial_state = iterator->
						history().first_initial_state(track);

					if(iterator_initial_state == track.end())
						iterator_initial_state = iterator;

					const float weight =
						weighted_longitudinal_fraction(
							iterator->momentum(), jet);

					if(comparison(member_function(
						*iterator_initial_state)))
						sum_match += weight;
					sum_total += weight;
				}

			return std::fpclassify(sum_total) != FP_ZERO ?
				sum_match / sum_total : 0.0F;
		}
		inline float first_initial_state_content(
			const jet_t &jet,
			const std::vector<track_t> &track,
			std::const_mem_fun_ref_t<bool, particle_t>
			member_function) const
		{
			return first_initial_state_content(
				jet, track,
				std::bind2nd(std::equal_to<bool>(), true),
				member_function);
		}
		// Heavy ion background related
		void orthogonal_statistics(
			float &mean, float &rms, const float azimuth) const;
	};

	class reconstruction_filtering_iir_t :
		public reconstruction_filtering_t {
	private:
		float _normalization;
		float _coefficient_pseudorapidity[22];
		float _coefficient_azimuth[22];
		static const std::string _revision;
		static std::vector<double_complex_t>
		adapt_pole(const double standard_deviation,
				   const std::vector<double_complex_t> &pole);
		double pole_gain(const std::vector<double_complex_t> &pole);
		double_complex_t gr(const double_complex_t pole_j,
						   const std::vector<double_complex_t> &pole,
						   double gain);
		void initialize_filter(float coefficient[],
							   const double standard_deviation,
							   const std::vector<double_complex_t> &
							   initial_pole);
		// Simple implementation
		void apply_forward(
			float output[], const float input[], const int n,
			const float *coefficient,
			const int stride = 1, const bool cyclic = false);
		void accumulate_forward(
			float output[], const float input[], const int n,
			const float *coefficient,
			const int stride = 1, const bool cyclic = false);
		void accumulate_backward(
			float output[], const float input[], const int n,
			const float *coefficient,
			const int stride = 1, const bool cyclic = false);
#ifdef HAVE_SSE
		// SSE array of structure version (cyclic)
		void apply_forward_aos_2(
			float output[], float input[], const int n,
			float *coefficient_1,
			float *coefficient_2);
		void accumulate_backward_aos_2(
			float output[], float input[], const int n,
			float *coefficient_1,
			float *coefficient_2);
		// SSE structure of array version (acyclic)
		void apply_forward_soa_4(
			float output[], float input[], const int n,
			float *coefficient,
			const int stride = 4);
		void accumulate_forward_soa_4(
			float output[], float input[], const int n,
			float *coefficient,
			const int stride = 4);
		void accumulate_backward_soa_4(
			float output[], float input[], const int n,
			float *coefficient,
			const int stride = 4);
#endif // HAVE_SSE
		void filter(const bool column_occupancy[]);
	public:
		inline std::string revision(void) const
		{
			return _revision;
		}
		typedef std::pair<float, float> float_pair_t;
		reconstruction_filtering_iir_t(
			const float standard_deviation,
			const float_pair_t pseudorapidity_range,
			const int npixel_pseudorapidity,
			const background_model_t &background_perp,
			const background_model_t &background_time,
			const background_model_t &background_z,
			const float *background_cache = NULL,
			const int npixel_azimuth = 256,
			const float_pair_t azimuth_range =
			float_pair_t(-(float)M_PI, (float)M_PI));
	};

	// See Intel MKL example
	// examples/dftc/source/real_2d_perm_single_ex2.c for details

	class reconstruction_filtering_fir_t :
		public reconstruction_filtering_t {
	private:
		static const std::string _revision;
		float *_filter_fourier_domain;
#ifdef HAVE_MKL
		DFTI_DESCRIPTOR_HANDLE _dfti_descriptor_handle;
		inline void dfti_error(const long status) const
		{
			std::cerr << __FILE__ << ':' << __LINE__
					  << ": MKL DFTI error (status = " << status
					  << ')' << std::endl;
			I(false);
		}
		inline void dfti_packed_multiply(
			float to[], const float from[], const int index,
			const int imaginary_stride) const
		{
			const int index_imaginary = index + imaginary_stride;

#ifndef __SIMULATE_C99_COMPLEX
			float _Complex product =
				(to[index] + to[index_imaginary] * _Complex_I) *
				(from[index] + from[index_imaginary] * _Complex_I);

			to[index] = crealf(product);
			to[index_imaginary] = cimagf(product);
#else // __SIMULATE_C99_COMPLEX
			const float real =
				to[index] * from[index] -
				to[index_imaginary] * from[index_imaginary];

			to[index_imaginary] =
				to[index] * from[index_imaginary] +
				to[index_imaginary] * from[index];
			to[index] = real;
#endif // __SIMULATE_C99_COMPLEX
		}
		void dfti_permuted_format_multiply(
			float a[], const float b[], const int m, const int n)
			const;
		void dfti_filter(const bool column_occupancy[]);
		void initialize_dfti_filter(void);
		inline void cleanup_dfti_filter(void)
		{
			if(_dfti_descriptor_handle != NULL) {
				DftiFreeDescriptor(&_dfti_descriptor_handle);
				_dfti_descriptor_handle = NULL;
			}
		}
#endif // HAVE_MKL
#ifdef HAVE_CUDA
		cufftHandle _cufft_plan[2];
		// A separate set of GPU mapped memory is required for CUDA
		cufftReal *_device_distribution;
		cufftComplex *_device_intermediate;
		cufftComplex *_device_filter_fourier_domain;
		void initialize_cufft_filter(void);
		void cufft_filter(const bool column_occupancy[]);
		inline void cleanup_cufft_filter(void)
		{
			cufft_destroy(_cufft_plan[0]);
			cufft_destroy(_cufft_plan[1]);
			cuda_free(reinterpret_cast<void *>
					  (_device_intermediate));
			cuda_free(reinterpret_cast<void *>
					  (_device_filter_fourier_domain));
		}
#endif // HAVE_CUDA
		inline void filter(const bool column_occupancy[])
		{
#if defined(HAVE_CUDA) && defined(USE_GPU)
			cufft_filter(column_occupancy);
#else // defined(HAVE_CUDA) && defined(USE_GPU)
#ifdef HAVE_MKL
			dfti_filter(column_occupancy);
#endif // HAVE_MKL
#endif // defined(HAVE_CUDA) && defined(USE_GPU)
		}
	public:
		inline std::string revision(void) const
		{
			return _revision;
		}
		typedef std::pair<float, float> float_pair_t;
		reconstruction_filtering_fir_t(
			const float standard_deviation,
			const float_pair_t pseudorapidity_range,
			const int npixel_pseudorapidity,
			const background_model_t &background_perp,
			const background_model_t &background_time,
			const background_model_t &background_z,
			const unsigned int filter_type = FILTER_TYPE_GAUSSIAN,
			const float *background_cache = NULL,
			const int npixel_azimuth = 512,
			const float_pair_t azimuth_range =
			float_pair_t(-(float)M_PI, (float)M_PI))
			: reconstruction_filtering_t(
				standard_deviation, pseudorapidity_range,
				npixel_pseudorapidity,
				background_perp, background_time, background_z,
				background_cache, npixel_azimuth, azimuth_range)
#ifdef HAVE_MKL
			, _dfti_descriptor_handle(NULL)
#endif // HAVE_MKL
		{
			_filter_type = filter_type;
#if defined(HAVE_CUDA) && defined(USE_GPU)
			initialize_cufft_filter();
#else // defined(HAVE_CUDA) && defined(USE_GPU)
#ifdef HAVE_MKL
			allocate_host();
			initialize_dfti_filter();
#endif // HAVE_MKL
#endif // defined(HAVE_CUDA) && defined(USE_GPU)
		}
		~reconstruction_filtering_fir_t(void)
		{
			if(_filter_fourier_domain != NULL) {
				delete [] _filter_fourier_domain;
				_filter_fourier_domain = NULL;
			}
#if defined(HAVE_CUDA) && defined(USE_GPU)
			cleanup_cufft_filter();
#else // defined(HAVE_CUDA) && defined(USE_GPU)
#ifdef HAVE_MKL
			free_host();
			cleanup_dfti_filter();
#endif // HAVE_MKL
#endif // defined(HAVE_CUDA) && defined(USE_GPU)
		}
	};

#ifdef __INTEL_COMPILER
#pragma warning(pop)
#endif // __INTEL_COMPILER

#ifdef HAVE_KTJET
	/**
	 * Jet filtering by the KtJet implementation of the k_T algorithm
	 */
	class reconstruction_ktjet_t : public reconstruction_t {
	private:
		double _radius;
		int _collision_type;
		int _distance_scheme;
		int _recombination_scheme;
		static KtJet::KtLorentzVector
		kt_lorentz_vector(const track_t &track);
		static snowmass_vector_t snowmass_vector(
			const KtJet::KtLorentzVector &pseudo_jet);
	public:
		enum {
			COLLISION_TYPE_EE = 1,
			COLLISION_TYPE_EP,
			COLLISION_TYPE_PE,
			COLLISION_TYPE_PP
		};
		enum {
			DISTANCE_SCHEME_ANGULAR = 1,
			DISTANCE_SCHEME_DELTA_R,
			DISTANCE_SCHEME_QCD
		};
		enum {
			RECOMBINATION_SCHEME_ENERGY = 1,
			RECOMBINATION_SCHEME_MOMENTUM_PERP,
			RECOMBINATION_SCHEME_MOMENTUM_PERP_SQUARE,
			RECOMBINATION_SCHEME_ENERGY_PERP,
			RECOMBINATION_SCHEME_ENERGY_PERP_SQUARE
		};
		inline reconstruction_ktjet_t(
			const double radius = 1.0,
			const int collision_type = COLLISION_TYPE_PP,
			const int distance_scheme = DISTANCE_SCHEME_QCD,
			const int recombination_scheme =
			RECOMBINATION_SCHEME_MOMENTUM_PERP)
			: _radius(radius), _collision_type(collision_type),
			  _distance_scheme(distance_scheme),
			  _recombination_scheme(recombination_scheme)
		{
		}
		std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true) = 0;
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track_begin, track_end, refine);
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		inline virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const
		{
			return 1.0F;
		}
	};
#endif // HAVE_KTJET

#ifdef HAVE_FASTJET
	/**
	 * Jet filtering by the FastJet implementation of the k_T
	 * algorithm
	 */
	class reconstruction_fastjet_t : public reconstruction_t {
	protected:
		static fastjet::PseudoJet pseudo_jet(const track_t &track);
		static snowmass_vector_t snowmass_vector(
			const fastjet::PseudoJet &pseudo_jet);
		fastjet::JetDefinition _jet_definition;
		float _resummation_radius;
		inline
		reconstruction_fastjet_t(
			fastjet::JetDefinition::Plugin *plug_in,
			const float resummation_radius = FLT_MAX)
			: _jet_definition(fastjet::JetDefinition(plug_in)),
			  _resummation_radius(resummation_radius)
		{
		}
	public:
		inline
		reconstruction_fastjet_t(
			const enum fastjet::JetAlgorithm algorithm,
			const double kt_distance = default_kt_distance,
			const float resummation_radius = FLT_MAX)
			: _jet_definition(fastjet::JetDefinition(
				algorithm, kt_distance)),
			  _resummation_radius(resummation_radius)
		{
		}
		inline
		reconstruction_fastjet_t(
			const double kt_distance = default_kt_distance,
			const float resummation_radius = FLT_MAX)
			: _jet_definition(fastjet::JetDefinition(
				fastjet::kt_algorithm, kt_distance)),
			  _resummation_radius(resummation_radius)
		{
		}
		inline ~reconstruction_fastjet_t(void)
		{
			if(_jet_definition.plugin() != NULL) {
				delete _jet_definition.plugin();
			}
		}
		virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true);
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track_begin, track_end, refine);
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		inline virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const
		{
			return 1.0F;
		}
		// Jet tagging related
		template<typename property_t, typename comparison_t>
		inline float first_initial_state_content(
			const jet_t &jet,
			const std::vector<track_t> &track,
			std::binder2nd<comparison_t> comparison,
			std::const_mem_fun_ref_t<property_t, particle_t>
			member_function) const
		{
			float sum_match = 0;
			float sum_total = 0;

			const std::vector<std::vector<track_t>::const_iterator> *
				constituent = &(jet._constituent);

			for(std::vector<std::vector<track_t>::
					const_iterator>::const_iterator
					iterator = constituent->begin();
				iterator != constituent->end(); iterator++)
				if((*iterator)->is_final_state()) {
					std::vector<track_t>::const_iterator
						iterator_initial_state = (*iterator)->
						history().first_initial_state(track);

					if(iterator_initial_state == track.end())
						iterator_initial_state = *iterator;

					const float weight = (*iterator)->momentum().
						longitudinal_fraction(jet);

					if(comparison(member_function(
						*iterator_initial_state)))
						sum_match += weight;
					sum_total += weight;
				}

			return std::fpclassify(sum_total) != FP_ZERO ?
				sum_match / sum_total : 0.0F;
		}
		inline float first_initial_state_content(
			const jet_t &jet,
			const std::vector<track_t> &track,
			std::const_mem_fun_ref_t<bool, particle_t>
			member_function) const
		{
			return first_initial_state_content(
				jet, track,
				std::bind2nd(std::equal_to<bool>(), true),
				member_function);
		}
	};

	/**
	 * Jet filtering by the FastJet implementation of the SISCone
	 * algorithm
	 */
	class reconstruction_siscone_t :
		public reconstruction_fastjet_t {
	public:
		inline
		reconstruction_siscone_t(
			const double cone_radius = default_cone_radius,
			const double overlap_threshold =
			default_siscone_overlap_threshold)
			: reconstruction_fastjet_t(
				new fastjet::SISConePlugin(
					cone_radius, overlap_threshold),
				cone_radius)
		{
		}
	};

	/**
	 * Jet filtering by the FastJet implementation of the SISCone
	 * algorithm
	 */
	class reconstruction_antikt_t :
		public reconstruction_fastjet_t {
	public:
		inline
		reconstruction_antikt_t(
			const double kt_distance = default_kt_distance,
			const float resummation_radius = FLT_MAX)
			: reconstruction_fastjet_t(
				fastjet::antikt_algorithm,
				default_kt_distance, resummation_radius)
		{
		}
	};

#ifdef HAVE_FASTJET_PXCONE
	// PXCONE
	const double default_min_jet_energy = 5.0;
	/**
	 * Jet filtering by the FastJet implementation of the SISCone
	 * algorithm
	 */
	class reconstruction_pxcone_t :
		public reconstruction_fastjet_t {
	public:
		inline
		reconstruction_pxcone_t(
			const double cone_radius = default_cone_radius,
			const double overlap_threshold =
			default_siscone_overlap_threshold,
			const double min_jet_energy =
			default_min_jet_energy)
			: reconstruction_fastjet_t(
				new fastjet::PxConePlugin(
					cone_radius, min_jet_energy, overlap_threshold),
				cone_radius)
		{
		}
	};
#endif // HAVE_FASTJET_PXCONE

#ifdef HAVE_FASTJET_CDF_MID_POINT
	// CDF midpoint
	const double default_seed_threshold = 1.0;

	/**
	 * Jet filtering by the FastJet implementation of the SISCone
	 * algorithm
	 */
	class reconstruction_cdf_midpoint_t :
		public reconstruction_fastjet_t {
	public:
		inline
		reconstruction_cdf_midpoint_t(
			const double cone_radius = default_cone_radius,
			const double overlap_threshold =
			default_siscone_overlap_threshold,
			const double seed_threshold =
			default_seed_threshold)
			: reconstruction_fastjet_t(
				new fastjet::PxConePlugin(
					cone_radius, overlap_threshold, seed_threshold),
				cone_radius)
		{
		}
	};
#endif // HAVE_FASTJET_CDF_MID_POINT

	/**
	 * Jet filtering by the FastJet implementation of the kT algorithm
	 * with area information
	 */
	class reconstruction_fastkt_area_t :
		public reconstruction_fastjet_t {
	private:
		bool _background_subtract;
		fastjet::AreaDefinition _area_definition;
		fastjet::RangeDefinition _range_definition;
		double _sigma_perp_over_area_background_threshold;
		double perp_per_area_scale(const double x) const;
		double sigma_perp_per_area_scale(const double x) const;
	public:
		inline
		reconstruction_fastkt_area_t(
			const enum fastjet::JetAlgorithm algorithm,
			const double kt_distance = default_kt_distance,
			const bool background_subtract = false,
			const fastjet::AreaDefinition area_definition =
			fastjet::VoronoiAreaSpec(),
			const fastjet::RangeDefinition range_definition =
			fastjet::RangeDefinition(3.0),
			const double sigma_perp_over_area_background_threshold =
			default_sigma_perp_over_area_background_threshold,
			const float resummation_radius = FLT_MAX)
			: reconstruction_fastjet_t(
				algorithm, kt_distance, resummation_radius),
			  _background_subtract(background_subtract),
			  _area_definition(area_definition),
			  _range_definition(range_definition),
			  _sigma_perp_over_area_background_threshold(
					sigma_perp_over_area_background_threshold)
		{
		}
		inline
		reconstruction_fastkt_area_t(
			const double kt_distance = default_kt_distance,
			const bool background_subtract = false,
			const fastjet::AreaDefinition area_definition =
			fastjet::VoronoiAreaSpec(),
			const fastjet::RangeDefinition range_definition =
			fastjet::RangeDefinition(3.0),
			const double sigma_perp_over_area_background_threshold =
			default_sigma_perp_over_area_background_threshold,
			const float resummation_radius = FLT_MAX)
			: reconstruction_fastjet_t(
				kt_distance, resummation_radius),
			  _background_subtract(background_subtract),
			  _area_definition(area_definition),
			  _range_definition(range_definition),
			  _sigma_perp_over_area_background_threshold(
					sigma_perp_over_area_background_threshold)
		{
		}
		std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true);
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track_begin, track_end, refine);
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		inline virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const
		{
			return 1.0F;
		}
	};
#endif // HAVE_FASTJET

	/**
	 * Leading particle "jet reconstruction", i.e. an identity
	 * operation on the tracks
	 */
	class reconstruction_leading_t : public reconstruction_t {
	public:
		std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true);
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track_begin, track_end, refine);
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		inline virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const
		{
			return 1.0F;
		}
	};

	/**
	 * Leading particle "jet reconstruction", i.e. an identity
	 * operation on the tracks
	 */
	class reconstruction_lohsc_t : public reconstruction_t {
	private:
		bool _background_subtract;
		float _fragment_cut_perp;
		float _seed_perp;
		float _inner_cone_radius;
		float _overlap_threshold;
	public:
		inline reconstruction_lohsc_t(
			const bool background_subtract,
			const float fragment_cut_perp =
			default_lohsc_fragment_cut_perp,
			const float seed_perp = default_lohsc_seed_perp,
			const float inner_cone_radius =
			default_lohsc_inner_cone_radius,
			const float overlap_threshold = 0.5F)
			: _background_subtract(background_subtract),
			  _fragment_cut_perp(fragment_cut_perp),
			  _seed_perp(seed_perp),
			  _inner_cone_radius(inner_cone_radius),
			  _overlap_threshold(overlap_threshold)
		{
		}
		std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const bool refine = true);
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t>::const_iterator &track_begin,
			const std::vector<track_t>::const_iterator &track_end,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track_begin, track_end, refine);
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end());
		}
		inline virtual std::vector<jet_t>
		reconstruct(
			const std::vector<track_t> &track,
			const collision_geometry_t &geometry,
			const bool refine = true)
		{
			return reconstruct(track.begin(), track.end(),
							   geometry, refine);
		}
		inline virtual float filter_weight(
			const snowmass_vector_t &fragment,
			const snowmass_vector_t &jet,
			const float radial_broadening = 0.0F) const
		{
			return 1.0F;
		}
	};

}

#endif // XJETREC_REC_H_
